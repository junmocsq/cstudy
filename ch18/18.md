## 18.声明
#### 存储类型
- 存储期限：变量的存储期限决定了为变量预留和内存被释放的时间。
    - 具有`自动存储期限`的变量在所属块被执行时获得内存单元，并在块终止时释放内存单元，从而会导致变量失去值。
    - 具有`静态存储期限`的变量在程序运行期间占用同一个的存储单元，也就允许变量无限期地保留它的值
- 作用域：变量的作用域是指可以引用变量的那部分文本。变量可以有
    - `块作用域`：变量从声明的地方一直到所在块的末尾是可见的
    - `文件作用域`：变量从声明的地方一直到所在文件的末尾都是可见的
- 链接：变量的链接确定了程序的不同部分可以共享此变量的范围。
    - 具有`外部链接`的变量可以被程序中的几个（或者全部）文件共享
    - 具有`内部链接`的变量只能属于单独一个文件，但是此文件中的函数可以共享这个变量。（如果具有相同名字的变量出现在另一个文件中，那么系统会把它作为不同的变量来处理）
    - `无链接`的变量属于单独一个函数，而且根本不能共享。
- 变量的默认存储期限、作用域和链接都依赖于变量声明的位置。
    - 在块（包括函数体）内部声明的变量具有自动存储期限、块作用域，并且无链接。
    - 在程序的最外层（任意块外部）声明的变量具有静态存储期限、文件作用域和外部链接。
- auto存储类型只对属于块的变量有效。具有自动存储期限、块作用域，并且无链接。
- static存储类型可用于全部变量，而无需考虑变量声明的位置。但是作用于块外部变量时，static说明变量具有内部链接。当用作块内部变量时，static存储期限从自动变为静态的。
    - 块内的static变量只在程序执行前进行一次初始化，而auto变量则会在每次出现时进行初始化（在初始化式里）。
    - 每次函数在递归调用时，它都会获得一组新的auto变量。但是，函数含有static变量，那么此函数的全部调用就会共享此static变量
    - `虽然函数不应该返回指向auto变量的指针，但是函数返回指向static变量的指针是没有问题的。`
- extern存储类型使几个源文件可以共享同一个变量。
    - extern声明中的变量始终具有静态存储期限。
    - 变量的作用域依赖于声明的位置。在块内部，那么变量具有块作用域；否则，变量具有文件作用域。
    - extern变量的链接，如果变量在文件中较早的位置（任何函数定义的外部）声明为static，那么它具有内部链接；否则（通常情况下），变量具有外部链接。
- register存储类型，要求编译器把变量存储在寄存器中，而不是像其他变量一样保存在内存中。但是编译器还是可以把register型变量存储在内存中。`register只对声明在块中的变量有效`。**由于寄存器没有地址，所以对register变量缺乏auto变量取地址是非法的。**
- 函数的存储类型：extern说明具有外部链接，默认也是外部链接。static使函数具有内部链接，所以在定义它的文件之外不能调用它。（但是不能阻挡函数指针进行间接调用.可以在static函数文件A中定义freturn()函数返回这个static函数指针f()，其他文件调用freturn()返回static函数指针(*f)()，实现了间接调用，参见1.c和2.c cc 1.c 2.c&& ./a.out）
#### other
- 解释复杂声明
    - `始终由内往外读声明符。`换句话说，定位声明的标识符，并且从此处开始解释声明
    - `在做选择时，始终使 [] 和 () 优先于 * 。`如果 * 在标识符的前面，而标识符后面跟着[],那么标识符表示数组而不是指针。同样的，如果 * 在标识符前面，而标识符后面跟着()，那么标识符表示函数而不是指针。（当然，可以使用圆括号来使 [] 和 () 相对于 * 的优先级无效）
- 函数不能返回数组，但是可以返回指向数组的指针；函数不能返回函数，但可以返回指向函数的指针；函数型的数组不合法，但是数组可以返回包含指向函数的指针。
```c
int(*f(int))[];     // int f(int)[] 不合法
int (*g(int))(int); // int g(int)(int) 不合法
int (*a[10])(int);  // int a[10](int) 不合法

int (*f(int v))[]
{
    static int arr[5] = {11, 22, 33, 44, 55};
    for(int i=0;i<5;i++){
        arr[i] += v;
    }
    return &arr;
}
// 调用例子
int (*res)[5] = f(10);
printf("%d %d\n",(*res)[0],(*res)[4]);
```
- 具有自动存储期限的变量没有默认的初始值。不能预测自动变量的初始值，而且每次变量变为有效时值可能不同
- 具有静态存储期限的变量默认情况下值为零。用calloc分配的内存是简单的给字节的位置零，而静态变量不同与此，它是基于类型的正确初始化，即整数变量初始化为0，浮点变量初始化为0.0，而指针则初始化为空指针。
- 出于书写风格的考虑，最好为静态类型的变量提供初始化式，而不是依赖于它们一定为零的事实。
- c99内联函数inline，建议编译器将代码内联编译。
```c
inline double average(double a,double b){
    return (a+b)/2;
}
// average()具有外部链接，所以其他在其他源文件也可以调用它，但是它有内联定义，所以试图在其他文件中调用它将失败。
// 可以在前面加上static 变为内部链接，这样其他文件要使用average函数就可以自己定义。
```
- c99的一般法则是，如果特定文件中某个函数的所有顶层声明中都有inline但没有extern，则该函数定义在该文件中是内联的。如果在程序的其他地方使用该函数（包含其内联定义的文件文件也算），则需要在另一个文件中为其提供外部定义。函数调用时，编译器可以选择进行正常调用（使用函数的外部定义）或者执行内联展开（使用函数的内联定义）。
```c
// average.h
#ifndef AVERAGE_H
#define AVERAGE_H
inline double average(double a,double b){
    return (a+b)/2;
}
#endif

// average.c
#include "average.h"
extern double average(double a,double b);
```
- 内联函数限制
  - 函数中不能定义可改变的static变量
  - 函数中不能引用具有内部链接的变量
- 关于gcc，仅当通过-O命令行选项请求进行优化时，才会对函数进行"内联"
- "作用域"和"链接"的区别是什么？
  - `作用域是为编译器服务的，而链接时为链接器服务的。`编译器用标识符的作用域来确定在文件的给定位置访问标识符是否合法。当编译器把源文件翻译成目标文件时，它会注意到有外部链接的名字，并最终把这些名字存储到目标文件内的一个表中。因此，链接器可以访问到具有外部链接的名字，而内部链接的名字或无链接的名字对链接器而言是不可见的。
- 在C语言中，const表示"只读"而不是"常量"。